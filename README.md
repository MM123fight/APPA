# APPA
This package contains the code which was used to implement algorithms in the paper

<< M. Lu and Z. Qu: An adaptive proximal point algorithm framework and application to large-scale optimization. >>

===============================================================================

This package implements AGPPA with preconditionner = I and relaxation factor = 1 for the general LP:

min c^Tx
s.t A_I * x <= b_I
    A_E * x <= b_E       (P)
    x[nb] >= 0
    
A_I: m_I x n, A_E: m_E x n.

===============================================================================

Let dir_name denote the PATH_TO_ROOT_WHERE_THIS_README_FILE_IS.

Our test data sets:

L1_SVM: real-sim, rcv1.multiclass, news20, avazu

Randomly generated sparse LP: M500000_100000_0.001, M1000000_100000_0.001, M1000000_200000_0.001, M10000000_100000_0.0001, M10000000_200000_0.0001, M10000000_500000_0.0001

Covering LP: C100000_500000_0.001, C100000_1000000_0.001, C200000_1000000_0.001, C100000_10000000_0.0001, C200000_10000000_0.0001, C500000_10000000_0.0001

L1_SVM uses real data from https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/
Randomly generated sparse LP problems uses artificial data generated by "LPgenerate.m"
Covering problems uses artificial data generated by "Covering.m"

Note that the data sets should be saved in the directory "data".

===============================================================================
Note: Recently, we have added directory ProblemGeneration indenpendently to transform L1_SVM problem to LP problem(it also shows how to give mps file): the detail is given in the readme.txt in ProblemGeneration and make.sh is given for convenience.

Of course, you can also generate the data using the code in APPA directly:

To compile the code to transform L1_SVM ptoblem to LP problem: use data real-sim for example
>> cd dir_name/data/real-sim
>> mkdir SVMtoLP
>> cd dir_name/Problem
>> g++ SVMtoLP.cpp -o SVMtoLP
>> ./SVMtoLP -k 2 -t 1 real-sim

Note that the generated data will be saved in "data/real-sim/SVMtoLP".

Here -k 2 means the number of classes for data real-sim is 2 and -t 1 means the type of the generated LP problem format is for AGPPA.

If you want to generate the data used for AGPPA, please use -t 1. By the way, -t 2 and -t 3  are the commands for generating formats for scs: https://github.com/cvxgrp/scs

The format generated by -t 1 can also be applied to the code LPsparse: http://ianyen.site/LPsparse/

See more details about the commands for parameters settings in "Problem/SVMtoLP_cmd_line.h"

================================================================================

To solve the LP problem derived from L1 SVM problem: use data real-sim as an example
>> cd dir_name/data/real-sim/SVMtoLP
>> mkdir result
>> cd dir_name/Algorithm
>> g++ PPA.cpp -o PPA
>> ./PPA -t 1e-5 real-sim/SVMtoLP

To solve Covering LP: use C100000_500000_0.001 as an example
>> cd dir_name/data/C100000_500000_0.001
>> mkdir result
>> cd dir_name/Algorithm
>> g++ PPA.cpp -o PPA
>> ./PPA -t 1e-5 C100000_500000_0.001

We can assemble the above process for randomly generated sparse LP.

Here -t 1e-5 means the accuracy is set as 1e-5. 

See more details about the commands for parameters settings in "Algorithm/ParamPPA.h"

The results will be saved in the corresponding directory "result" which is made by the command:
<< mkdir result

================================================================================

The general LP problem can be reformulated into the standard form with n_b = 0 and then we can apply AGPPA to such form. We call such application as AGPPAi. Note that we can apply AGPPi to both primal problem (P) and its dual problem.

LP problem (P) transformed from L1_SVM prblem: use data set real-sim as an example

if m_I > n_b, we first transform primal problem (P) to the standard form:
>> cd dir_name/data/real-sim
>> mkdir SVMtoLP_inequ
>> cd dir_name/Problem
>> g++ LPtoLP_inequ.cpp -o LPtoLP_inequ
>> ./LPtoLP_inequ real-sim/SVMtoLP
then we apply AGPPA to data set "data/real-sim/SVMtoLP_inequ"

else we transform dual problem of (P) to the standard form:
>> cd dir_name/data/real-sim
>> mkdir SVMtoLP_d_inequ
>> cd dir_name/Problem
>> g++ LPtoLPd_inequ.cpp -o LPtoLPd_inequ
>> ./LPtoLPd_inequ real-sim/SVMtoLP
then we apply AGPPA to data set "data/real-sim/SVMtoLPd_inequ"

Covering problem: use data set C100000_500000_0.001 as an example


if m_I > n_b, we first transform primal problem (P) to the standard form:
>> cd dir_name/data
>> mkdir C100000_500000_0.001_inequ
>> cd dir_name/Problem
>> g++ LPtoLP_inequ.cpp -o LPtoLP_inequ
>> ./LPtoLP_inequ C100000_500000_0.001
and we apply AGPPA to data set "data/C100000_500000_0.001_inequ"

else we transform dual problem of (P) to the standard form: 
>> cd dir_name/data
>> mkdir C100000_500000_0.001_d_inequ
>> cd dir_name/Problem
>> g++ LPtoLPd_inequ.cpp -o LPtoLPd_inequ
>> ./LPtoLPd_inequ C100000_500000_0.001_d_inequ
and apply AGPPA to data set "data/C100000_500000_0.001_d_inequ"

We can assemble the above process for randomly generated sparse LP.


================================================================================
